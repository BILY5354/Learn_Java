# [面向对象编程（高级部分）](./TCH_Han/Chapter10.md)  
# 值得注意的概念
- 
- 
- 
-  
1. [类变量和类方法](#1)
2. [理解```main```方法语法](#2)
3. [代码块](#3)
4. [单例设计模式](#4)
4. [```final```关键字](#5)
4. [抽象类](#6)
4. [抽象类最佳实践---模板设计模式](#7)
4. [接口](#8)
4. [内部类](#9)
4. [卖油翁和老黄牛](#10)
5. [作业](#作业)  
# 1

## 1.1 类变量快速入门

```java
//略
```





## 1.2 类变量与类方法

### 1.2.1 类变量与定义

- 类变量也叫**静态变量**/**静态属性**，是该类所有对象共享的变量，任何一个该类对象去访问它时，取到的都是相同的值
  1. ```staic```变量是同一个类中所有对象共享
  2. ```staic```类变量，在类加载时候就生产
  3. [那么和之前说的属性有啥区别呢](https://www.cnblogs.com/zxan/p/7277876.html)
- 定义：

```java
访问修饰符 static 数据类型 变量名; //推荐
static 访问修饰符 数据类型 变量名;
```



### 1.2.2 类变量内存剖析

```JDK```版本不同可能会导致静态变量存储的位置不同，但是要注意的是：

 - ```staic```变量是**同一个类**中所有对象共享

 -  ```staic```类变量，在类加载时候就生产

  

### 1.2.3 类变量使用注意事项与细节讨论

1. 什么时候需要用类变量：

   - 当需要让某个类的所有对象都共享一个变量是，就可以考虑使用类变量（静态变量）

2. 类变量与实例变量（普通属性）区别：

   - **类变量**是该类的所有对象**共享**的，而**实例变量**是每个对象**独享**的

3. 加上```static```称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

4. 类变量的方法方式有：（前提是满足访问修饰符的访问权限和范围）

   ```java
   类名.类变量名	//推荐 注意！实例变量此种访问方式错误
   对象名.类变量名
   ```

5. 类变量是在类加载是就初始化了，也就是即使没有创建对象，只要类加载了，就可以使用类变量
6. 类变量的生命周期是随类的加载开始，随着类消亡而销毁（看例子）

```java
package com.hspedu.static_; 

public class StaticDetail { 
    public static void main(String[] args) { 
        B b = new B(); 
        //System.out.println(B.n1); 
        System.out.println(B.n2); //静态变量是类加载的时候，就创建了,所以我们没有创建对象实例 
        System.out.println(C.address);  //也可通过类名.类变量名来访问
    } 
}

class B { 
    public int n1 = 100; 
    public static int n2 = 200; 
}

class C { 
    public static String address = "北京"; 
}
```






### 1.2.4 类方法基本介绍

- 类方法也叫静态方法

```java
访问修饰符 static 数据返回类型 方法名() {}//推荐
static 访问修饰符 数据返回类型 方法名() {}
```

- 类方法的调用**前提是**满足访问修饰符的访问权限

```java
class B {
    public static void printStart () {
        System.out.println("打印星星...");
    }
}
```



类方法使用案例

```java
package com.hspedu.static_; 

public class StaticMethod {
    public static void main(String[] args) { 
        
        //创建 2 个学生对象，叫学费 
        Stu tom = new Stu("tom"); 
        //tom.payFee(100); 
        Stu.payFee(100);//对不对?对 
        
        Stu mary = new Stu("mary"); 
        //mary.payFee(200); 
        Stu.payFee(200);//对 
        
        Stu.showFee();//300  输出当前收到的总学费 
        
        //如果希望不创建实例，也可以调用某个方法(即当做工具来使用) //这时，把方法做成静态方法时非常合适 
        System.out.println("9 开平方的结果是=" + Math.sqrt(9)); 
        System.out.println(MyTools.calSum(10, 30)); 
    } 
}

//开发自己的工具类时，可以将方法做成静态的，方便调用 
class MyTools { 
    //求出两个数的和 
    public static double calSum(double n1, double n2) {
        return n1 + n2; 
    }
    //可以写出很多这样的工具方法... 
}

class Stu { 
    private String name;//普通成员 
    //定义一个静态变量，来累积学生的学费 
    private static double fee = 0; 
    
    public Stu(String name) { 
        this.name = name; 
    }
    //说明 
    //1. 当方法使用了 static 修饰后，该方法就是静态方法 
    //2. 静态方法就可以访问静态属性/变量 
    public static void payFee(double fee) { 
        Stu.fee += fee;//累积到 
    }
    public static void showFee() { 
        System.out.println("总学费有:" + Stu.fee); 
    } 
}
```

  

  

### 1.2.5 类方法经典使用场景

- 当方法中不涉及到任何对象相关的成员，则可以将方法设计成静态方法，提高开发效率
- 在程序实际开发，往往会将一些通用的方法，设计成静态方法，这样便不需要创建对象可以使用，比如打印一维数组、冒泡排序，完成某个计算任务等
- 如```Math```类、```Arrays```类、```Collections```集合类看看源码



### 1.2.6 类方法使用注意事项和细节讨论

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：
   - 类方法中无```this```参数
   - 普通方法中隐含```this```参数
2. 类方法可以通过类名调用，也可以通过对象名调用。
3. **普通方法**和对象有关，需要通过对象名调用，比如```对象名.方法名(参数)```，**不能通过类名调用**。
4. **类方法**中不允许使用和对象有关的关键字，**比如```this```和```super```**。```普通方法(成员方法)```可以。
5. ```类方法(静态方法)```中，**只能**访问**静态成员**，也可以访问**静态方法**。
6. 普通成员方案，**即**可以访问非静态成员，**也**可以访问静态成员。

**小结**：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员（必须遵循访问权限）。

```java
package com.hspedu.static_; 

public class StaticMethodDetail { 
    public static void main(String[] args) {
        D.hi();//ok 
        //D.say();, 错误，非静态方法，不能通过类名调用 需要先创建对象，再调用 
        new D().say();//可以
        } 
}

class D { 
    private int n1 = 100; 
    private static int n2 = 200;
    public void say() {//非静态方法,普通方法 
    }
    public static void hi() {//静态方法,类方法 
        n1 = 0;//错误，类方法中不允许使用和对象有关的关键字， 
        //比如 this 和 super。普通方法(成员方法)可以。 
        //System.out.println(this.n1); 错误的
    }
    
    //类方法(静态方法)中 只能访问 静态变量 或静态方法 
    //口诀:静态方法只能访问静态成员. 
    public static void hello() { 
        System.out.println(n2); 
        System.out.println(D.n2); 
        //System.out.println(this.n2);不能使用 
        hi();//OK 
        //say();//错误 
    }
    //普通成员方法，既可以访问 非静态成员，也可以访问静态成员
    
    //小结: 非静态方法可以访问 静态成员和非静态成员 
    public void ok() { 
        //非静态成员 
        System.out.println(n1); 
        say(); 
        //静态成员 
        System.out.println(n2); 
        hello(); 
    } 
}
```



### 1.2.7  课堂练习(1)：判断```total```值

[不用```this```如何给```total```赋值呢？](#1.2.3 类变量使用注意事项与细节讨论)。

```java
class TestPerson {
    public static void main(String[] args) {

        Person.setTotalPerson(3);
        new Person();
        Person.m();
    }
}

class Person { //StaticExercise03.java 2min 看
    private int id;
    private static int total = 0;
    public static void setTotalPerson(int total){
        
        // this.total = total;//错误，因为在static方法中，不可以使用this 关键字
        Person.total = total;//想要给total赋值就使用 类.静态属性
    }
    public Person() {//构造器
        total++;
        id = total;
    }
    public static void m() {//编写一个方法，输出total的值
        System.out.println("total的值=" + total);
    }
}
```

答案是4，**小结**：

- 静态方法只能访问静态成员（属性和方法）
- 非静态方法可以访问所有的成员
- 在编写代码时，仍然遵守访问权限规则

# 2

## 2.1 理解```main```方法语法

<img src="../img/TCH_Han/ch10_1.png" style="zoom:87%;" />

```java
public class myHomework {
	public static void main(String[] args) {

		for (int i = 0; i < args.length; i++) {
			System.out.println(i + "\t" +args[i]);
		}
	}
}
```
<img src="../img/TCH_Han/ch10_2.png" style="zoom:87%;" />



## 2.2 值得注意的地方

```java
package com.hspedu.main_;

public class Main01 {

    //静态的变量/属性
    private static  String name = "韩老师代码";
    //非静态的变量/属性
    private int n1 = 10000;

    //静态方法
    public static  void hi() {
        System.out.println("Main01的 hi方法");
    }
    //非静态方法
    public void cry() {
        System.out.println("Main01的 cry方法");
    }

    public static void main(String[] args) {

        //可以直接使用 name
        //1. 静态方法main 可以访问本类的静态成员
        System.out.println("name=" + name);
        hi();
        //2. 静态方法main 不可以访问本类的非静态成员
        //System.out.println("n1=" + n1);//错误
        //cry();
        //3. 静态方法main 要访问本类的非静态成员，需要先创建对象 , 再调用即可
        Main01 main01 = new Main01();
        System.out.println(main01.n1);//ok
        main01.cry();
    }
}
```

<img src="../img/TCH_Han/ch10_3.png" style="zoom:87%;" />

## 2.3 案例演示





# 3

## 3.1 代码块基本介绍

- 代码块又称为初始化块，属于类中的成员（类中的一部分），类似于方法，将逻辑语句封装在方法体中，通过```{}```包围起来

- 但与方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时**隐式调用**



## 3.2 代码块基本语法

1. 修饰符 可选，要写也只能写```static```。
2. 代码块分为两类，使用```static```修饰的叫静态代码块，没有```static```修饰时，交普通代码块/非静态代码块。
3. 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）。
4. ```;```可以写上，也可以省略。

```java
[修饰符] {
  代码  
};
```





## 3.3 代码块快速入门

### 好处

1. 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作。
2. 场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性。

```java
```



## 3.4 代码块使用注意事项与细节讨论

1. ```static```代码块也称静态代码块，作用就是对类进行初始化，而且随**类的加载**而执行，并且**只会执行一次**。如果是普通代码块，没创建一个对象，就执行。
2. 类什么时候被加载（**重点**）
   - 创建对象实例时```new```
   - 创建子类对象实例，父类也会被加载
   - 使用类的静态成员时（静态属性、静态方法）
   - 案例
3. 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。

> 小结：
>
> 1. ```static```代码块是类加载时，执行，只会执行一次
> 2. 普通代码块是在创建对象时掉调用的，创建一次，调用一次
> 3. 类加载的3中情况，牢记



```java
```



4. 创建一个对象时，在一个类调用顺序是（**重点难点**）
   1. 调用静态代码块和静态属性初始化
      - 注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按其定义的顺序调用 案例
   2. 调用普通代码块和普通属性的初始化
      - 注意：普通代码块和普通属性初始化调用优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用
   3. 调用构造方法



```java
```



5. 构造器的最前面其实隐含了```super()```和调用普通代码块，新写一个类演示，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此优先于构造器和普通代码块执行的

   ```java
   class A {
       public A() {//构造器
           //这里有隐藏的执行要求
           //(1)super();
           //(2)调用普通代码块的
           System.out.println("ok");
       }
   }
   ```



6. 创建一个子类对象时（继承关系），其静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下

   1. 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   2. 子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   3. 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   4. 父类的构造方法
   5. 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   6. 子类的构造方法

   演示



7. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。（学习比较麻烦工作轻松）







# 4

## 4.1 单例设计模式



```
```



## 4.2 单例模式简介



## 4.3 单例模式应用实例

步骤：

1. 构造器私有化 防止直接```new```
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法 ```getInstance```
4. 代码实现那



## 4.4 饿汉式 vs 懒汉式



# 5

## 5.1 ```final```关键字基本介绍

- ```final```可以修饰类、属性、方法和局部变量

出现一下情况就会使用到```final```：

1. 当不希望类**被继承**时，可以用```final```修饰
2. 当不希望父类的某个方法**被子类覆盖/重写**时，可以用```final```关键字修饰 案例
3. 当不希望类的某个属性的值被修改时
4. 当不希望某个局部变量被修改，可以用```final```修饰

````java
````





## 5.2 ```final```关键字使用注意事项和细节讨论

1. ```final```修饰的属性又叫常量，一般用```XX_XX_XX```命名。

2. ```final```修饰的属性在定义时，必须**赋初值，并不能再修改**，赋值可以在如下位置之一：

   - 定义时：```public final```
   - 在构造器中
   - 在代码块中

3. 如果```final```修饰的属性是静态的，则初始化的位置只能是

   - 定义时
   - 在静态代码块 不能在构造器中赋值

4. ```final```类不能继承，但是可以实例化对象

5. 如果类不是```final```类，但是含有```final```方法，则改方法虽然不能重写，但是可以被继承。

6. 一般来说，如果一个类已经是```final```类，就没有必要将方法修饰成```final```方法

7. ```final```不能修饰构造方法

8. ```final```和```static```往往搭配使用效率更高，不会导致类加载，递增编译器做了优化处理

   ```java
   class Demo {
       public static final int i =16;
       static {
           System.out.println("CDUY");
       }
   }
   ```

9. 包装类等```Interger、Double、Float、Boolean```等都是```final```，```String```也是```final```类



```java
```





## 5. ```final```应用实例

# 6

## 6.1 抽象类快速入门

 ### 6.1.1 先看一个案例



### 6.1.2 入门

当父类的一些方法不能确定时，可以用```abstract```关键字来修饰该方法，这个方法就是抽象方法，用```abstract```来修饰该类就是抽象类。

例子





## 6.2 抽象类介绍

1. 用```abstract```关键字来修饰一个类时，这个嘞就叫抽象类

   ```java
   abstract class Animal {
       String name;
       int age;
       abstract public void cry();
   }
   ```

2. 用```abstract```关键字来修饰一个方法时，这个方法就是抽象方法
3. 抽象类的价值更多作用是在与设计，是设计者设计好后，让子类继承并实现抽象类
4. 抽象类，是面试常问的知识点，在框架和设计模式使用较多



## 6.3 抽象类使用事项和细节讨论

1. 抽象类不能被实例化

2. 抽象类不一定包含```abstract```方法，也就是说，抽象类可以没有```abstract```方法

3. 一旦类包含了```abstract```方法，则这个类必须声明为```abstract```

4. ```abstract```只能修饰类和方法，不能修饰属性和其它的

   ```java
   ```

5. 抽象类可以有任意成员**抽象类本质还是类**，比如：非抽象方法、构造器、静态属性

6. 抽象方法不能有主题，即不能实现

7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为```abstract```类

   ```java
   ```

8. 抽象方法不能使用```private```、```final```、```abstract```、```static```来修饰，因为这些关键字都是和重写相违背的



## 6.4 课堂练习(1)：抽象类



## 6.5 抽象类最佳实践-模板设计模式



# 7

## 7.1 接口快速入门



## 7.2 接口基本介绍

### 7.2.1  讨论



### 7.2.2 注意事项和细节

1. 接口不能被实例化

2. 接口中的所有方法时```public```方法，接口中抽象方法，可以不用```abstract```西施

3. 一个普通类实现接口，就必须将该接口的所有方法都实现

4. 抽象类实现接口，可以不用实现接口的方法

   ```java
   
   ```

5. 一个类同时可以实现多个接口

6. 接口的属性只能是```final```的，而且是```public static final```修饰符，比如：```int a = 1;```实际上是```public static final int a = 1;````**必须初始化**。

7. 接口中属性的访问形式：```接口名.属性名```

8. 接口不能继承其它的类，但是可以继承多个别的接口

   ```interface A extends B, C { } ```

9. 接口的修饰符只能是```public```和默认，这点和类的修饰符是一样的



## 7.？ 实现接口 VS 继承类



## 7. 接口的多态特性



# 8

## 8.1 内部类基本介绍

1. 定义类在局部位置（方法中/代码块）
   - 局部内部类
   - 匿名内部类
2. 定义在成员位置
   - 成员内部类
   - 静态内部类



一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类，嵌套其它的类称为外部类。是我妈类的第五大成员，内部类的最大的特点就是可以直接访问私有属性



## 8.2 基本语法







# 作业

```
```